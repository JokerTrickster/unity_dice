---
task_id: 05
name: matching-ui-system
updated: 2025-09-02T10:51:22Zgithub: https://github.com/JokerTrickster/unity_dice/issues/29epic: main-page-screen
status: pending
priority: high
estimated_hours: 18
depends_on: [04]
created: 2025-09-01T05:00:23Z
---

# Task 05: 매칭 UI 및 랜덤 매칭 시스템

## Overview
WebSocketClient를 활용하여 실시간 랜덤 매칭 시스템과 사용자 인터페이스를 구현합니다. 2-4명 인원수 선택, 랜덤 매칭 요청, 매칭 진행 상태 표시, 매칭 취소 기능을 포함합니다.

## Technical Requirements

### UI Flow Design
```
MatchingSection
├── PlayerCountSelector (2, 3, 4명 버튼)
├── MatchTypeSelector
│   ├── RandomMatchingButton
│   └── RoomMatchingButton (Task 06에서 구현)
├── MatchingStatusDisplay
│   ├── WaitingState (대기 중...)
│   ├── SearchingState (매칭 검색 중... + 애니메이션)
│   ├── FoundState (매칭 완료!)
│   └── CancelButton (매칭 중에만 표시)
└── MatchingResultModal
    ├── PlayerList (매칭된 플레이어들)
    ├── GameStartCountdown (3, 2, 1...)
    └── StartGameButton
```

### State Management
```csharp
public enum MatchingState {
    Idle,           // 매칭 대기
    Searching,      // 매칭 검색 중
    Found,          // 매칭 완료
    Starting,       // 게임 시작 중
    Cancelled,      // 매칭 취소됨
    Failed          // 매칭 실패
}

public class MatchingManager : MonoBehaviour {
    public MatchingState currentState;
    public MatchingData currentMatchingData;
    public event Action<MatchingState> OnStateChanged;
}
```

## Implementation Details

### Core Components
1. **MatchingManager.cs** (Singleton)
   - WebSocketClient와 연동하여 매칭 요청 처리
   - 매칭 상태 관리 및 UI 업데이트 조정
   - EnergyManager와 연동하여 피로도 검증

2. **MatchingUI.cs**
   - 인원수 선택 및 매칭 타입 버튼 관리
   - 매칭 상태에 따른 UI 변화 처리
   - 취소 버튼 및 확인 다이얼로그

3. **MatchingStatusDisplay.cs**
   - 실시간 매칭 진행 상태 애니메이션
   - 매칭 대기 시간 표시
   - 매칭 완료 시 결과 표시

### Matching Flow Implementation
```csharp
public class MatchingFlow {
    public async Task StartRandomMatching(int playerCount) {
        // 1. 피로도 검증
        if (!EnergyManager.Instance.CanStartGame()) {
            ShowEnergyRequiredDialog();
            return;
        }
        
        // 2. 매칭 요청 생성
        var request = new MatchingRequest {
            playerCount = playerCount,
            matchType = "random",
            playerId = UserDataManager.Instance.GetUserId()
        };
        
        // 3. WebSocket으로 매칭 요청 전송
        ChangeState(MatchingState.Searching);
        await NetworkManager.Instance.SendMatchingRequest(request);
        
        // 4. 매칭 응답 대기 (타임아웃 60초)
        StartCoroutine(MatchingTimeoutCoroutine(60f));
    }
    
    void OnMatchingResponse(MatchingResponse response) {
        if (response.success) {
            ChangeState(MatchingState.Found);
            DisplayMatchingResult(response);
            StartGameCountdown();
        } else {
            ChangeState(MatchingState.Failed);
            ShowMatchingFailedDialog(response.error);
        }
    }
}
```

### WebSocket Message Handling
```csharp
void OnWebSocketMessage(string message) {
    var response = JsonUtility.FromJson<MatchingResponse>(message);
    
    switch (response.type) {
        case "matching_found":
            OnMatchingFound(response);
            break;
        case "matching_cancelled":
            OnMatchingCancelled(response);
            break;
        case "matching_failed":
            OnMatchingFailed(response);
            break;
        case "game_starting":
            OnGameStarting(response);
            break;
    }
}
```

## UI Animation & Feedback

### Matching Progress Animation
```csharp
public class MatchingProgressAnimator : MonoBehaviour {
    public Image[] searchingDots;
    public float animationSpeed = 0.5f;
    
    IEnumerator AnimateSearching() {
        while (currentState == MatchingState.Searching) {
            for (int i = 0; i < searchingDots.Length; i++) {
                searchingDots[i].color = Color.white;
                yield return new WaitForSeconds(animationSpeed);
                searchingDots[i].color = Color.gray;
            }
        }
    }
}
```

### Player Count Selection
```csharp
public class PlayerCountSelector : MonoBehaviour {
    public Button[] playerCountButtons; // 2, 3, 4명 버튼
    private int selectedCount = 2;
    
    void Start() {
        for (int i = 0; i < playerCountButtons.Length; i++) {
            int count = i + 2; // 2, 3, 4
            playerCountButtons[i].onClick.AddListener(() => SelectPlayerCount(count));
        }
        SelectPlayerCount(2); // 기본값
    }
    
    void SelectPlayerCount(int count) {
        selectedCount = count;
        UpdateButtonVisuals();
    }
}
```

## Acceptance Criteria

### Functional Requirements
- [ ] 2-4명 인원수 선택 UI 정상 작동
- [ ] 랜덤 매칭 버튼 클릭 시 WebSocket으로 매칭 요청 전송
- [ ] 매칭 중 실시간 상태 표시 및 애니메이션
- [ ] 매칭 취소 버튼으로 언제든 매칭 중단 가능
- [ ] 매칭 완료 시 플레이어 목록 표시
- [ ] 게임 시작 카운트다운 후 게임 화면 전환

### Technical Requirements
- [ ] WebSocketClient와 완벽 연동 (Task 04 의존)
- [ ] EnergyManager와 연동하여 피로도 검증
- [ ] 매칭 상태 기반 UI 자동 업데이트
- [ ] 네트워크 오류 시 적절한 에러 처리
- [ ] 메모리 효율적인 UI 상태 관리

### Performance Requirements
- [ ] 매칭 요청 응답시간 2초 이내
- [ ] UI 애니메이션 60FPS 유지
- [ ] 매칭 취소 즉시 반응 (1초 이내)
- [ ] 메모리 사용량 증가 5MB 이하

## Testing Strategy

### Unit Tests
- `MatchingManagerTests.cs`: 매칭 로직 및 상태 관리
- `PlayerCountSelectorTests.cs`: 인원수 선택 로직
- `MatchingUITests.cs`: UI 상태 변화 테스트

### Integration Tests
- WebSocketClient와 매칭 요청/응답 테스트
- EnergyManager 피로도 검증 연동 테스트
- 매칭 완료 후 게임 시작 플로우 테스트

### Scenario Tests
- 매칭 성공 시나리오 (2-4명 각각)
- 매칭 실패 시나리오 (타임아웃, 서버 오류)
- 매칭 중 취소 시나리오
- 네트워크 연결 끊김 중 매칭 시나리오

## Error Handling

### Matching Failures
- 타임아웃 시 자동 매칭 취소 및 사용자 알림
- 서버 오류 시 재시도 옵션 제공
- 연결 끊김 시 자동 재연결 후 상태 복구

### Energy Validation
- 매칭 시작 전 피로도 부족 시 구매 안내
- 매칭 중 피로도 부족 발견 시 매칭 취소
- 게임 시작 직전 피로도 재검증

### UI State Management
- 예상치 못한 상태 변화 시 안전한 기본 상태로 복구
- 동시 버튼 클릭 방지 (버튼 비활성화)
- 앱 백그라운드 전환 시 매칭 상태 보존

## Dependencies
- **Internal**: WebSocketClient (Task 04), EnergyManager (Task 03), UserDataManager
- **External**: Unity UI, Coroutines, Animation System

## Localization Support
```json
{
  "matching": {
    "selectPlayers": "인원 수 선택",
    "randomMatch": "랜덤 매칭",
    "searching": "매칭 검색 중...",
    "found": "매칭 완료!",
    "cancelled": "매칭이 취소되었습니다",
    "failed": "매칭에 실패했습니다",
    "startingSoon": "게임이 곧 시작됩니다",
    "energyRequired": "게임 시작을 위해 피로도가 필요합니다"
  }
}
```

## Analytics Integration
```csharp
public class MatchingAnalytics {
    public void TrackMatchingStarted(int playerCount) {
        // 매칭 시작 이벤트 로깅
    }
    
    public void TrackMatchingCompleted(float waitTime, int playerCount) {
        // 매칭 완료 및 대기 시간 로깅  
    }
    
    public void TrackMatchingCancelled(float waitTime) {
        // 매칭 취소 및 대기 시간 로깅
    }
}
```

## Definition of Done
- [ ] 모든 랜덤 매칭 기능 정상 작동
- [ ] WebSocketClient와 완벽 연동 검증
- [ ] 피로도 시스템과 완벽 통합
- [ ] 모든 에러 시나리오 처리 완료
- [ ] UI 애니메이션 및 사용자 경험 검증
- [ ] 단위/통합/시나리오 테스트 모두 통과
- [ ] 성능 기준 및 메모리 요구사항 달성
- [ ] 로컬라이제이션 및 접근성 준수