---
task_id: 09
name: integration-testing
updated: 2025-09-02T10:51:24Zgithub: https://github.com/JokerTrickster/unity_dice/issues/33epic: main-page-screen
status: pending
priority: high
estimated_hours: 20
depends_on: [02, 03, 05, 06, 07, 08]
created: 2025-09-01T05:00:23Z
---

# Task 09: 통합 테스트 및 에러 처리 강화

## Overview
메인 페이지 시스템의 모든 컴포넌트가 완성된 후, 전체 시스템의 통합 테스트를 수행하고 에러 처리를 강화합니다. 실제 사용 시나리오를 바탕으로 한 종단간(E2E) 테스트와 예외 상황 처리를 중점적으로 검증합니다.

## Technical Requirements

### Integration Test Scope
모든 주요 컴포넌트 간 상호작용 검증:
- ProfileSection ↔ UserDataManager
- EnergySystem ↔ NetworkManager ↔ Game Flow
- MatchingSystem ↔ WebSocketClient ↔ EnergySystem
- MailboxSystem ↔ NetworkManager ↔ EnergySystem
- SettingsSection ↔ SettingsManager ↔ AudioManager

### Test Categories
```csharp
public enum TestCategory {
    UserFlow,           // 사용자 플로우 시나리오
    SystemIntegration,  // 시스템 간 통합
    ErrorRecovery,      // 에러 복구 및 처리
    Performance,        // 성능 및 메모리
    NetworkResilience,  // 네트워크 장애 대응
    DataConsistency     // 데이터 일관성
}
```

## Implementation Details

### Core Test Components
1. **MainPageIntegrationTests.cs**
   - 전체 메인 페이지 라이프사이클 테스트
   - 컴포넌트 간 데이터 흐름 검증
   - 메모리 누수 및 성능 모니터링

2. **UserFlowTests.cs**
   - 실제 사용자 시나리오 기반 테스트
   - 터치 이벤트 및 UI 인터랙션 검증
   - 플로우 중단 및 복구 테스트

3. **ErrorRecoveryTests.cs**
   - 예외 상황 및 에러 복구 시나리오
   - 네트워크 장애 시뮬레이션
   - 데이터 손상 복구 테스트

### User Flow Test Scenarios

#### Scenario 1: 완전한 게임 시작 플로우
```csharp
[UnityTest]
public IEnumerator CompleteGameStartFlow() {
    // 1. 메인 페이지 로드
    yield return LoadMainPage();
    Assert.IsTrue(mainPageManager.IsInitialized);
    
    // 2. 프로필 정보 확인
    Assert.IsNotNull(profileSection.GetDisplayedNickname());
    
    // 3. 피로도 확인
    int initialEnergy = energyManager.GetCurrentEnergy();
    Assert.IsTrue(initialEnergy > 0, "게임 시작을 위한 피로도 부족");
    
    // 4. 랜덤 매칭 시작
    yield return StartRandomMatching(2);
    Assert.AreEqual(MatchingState.Searching, matchingManager.CurrentState);
    
    // 5. 매칭 완료 시뮬레이션
    yield return SimulateMatchingSuccess();
    Assert.AreEqual(MatchingState.Found, matchingManager.CurrentState);
    
    // 6. 게임 시작
    yield return StartGame();
    Assert.AreEqual(initialEnergy - 1, energyManager.GetCurrentEnergy());
}
```

#### Scenario 2: 피로도 구매 및 게임 시작
```csharp
[UnityTest]
public IEnumerator EnergyPurchaseAndGameStart() {
    // 1. 피로도 0 상태 설정
    energyManager.SetEnergy(0);
    
    // 2. 게임 시작 시도 (실패해야 함)
    yield return AttemptGameStart();
    Assert.IsFalse(matchingManager.IsMatching);
    
    // 3. 피로도 구매 모달 표시 확인
    Assert.IsTrue(energyPurchaseUI.IsVisible);
    
    // 4. 피로도 구매 실행
    yield return PurchaseEnergy(10);
    Assert.AreEqual(10, energyManager.GetCurrentEnergy());
    
    // 5. 게임 시작 재시도 (성공해야 함)
    yield return AttemptGameStart();
    Assert.IsTrue(matchingManager.IsMatching);
}
```

#### Scenario 3: 방 생성 및 친구 초대 플로우
```csharp
[UnityTest]
public IEnumerator RoomCreationAndInviteFlow() {
    // 1. 방 생성
    yield return CreateRoom(3);
    Assert.IsNotNull(roomManager.CurrentRoom);
    Assert.IsTrue(roomManager.IsHost);
    
    // 2. 방 코드 생성 확인
    string roomCode = roomManager.CurrentRoom.roomCode;
    Assert.AreEqual(4, roomCode.Length);
    Assert.IsTrue(int.TryParse(roomCode, out _));
    
    // 3. 방 코드 복사
    roomUI.CopyRoomCode();
    Assert.AreEqual(roomCode, GUIUtility.systemCopyBuffer);
    
    // 4. 플레이어 참여 시뮬레이션
    yield return SimulatePlayerJoin(roomCode, "TestPlayer1");
    Assert.AreEqual(2, roomManager.CurrentRoom.players.Count);
    
    // 5. 게임 시작
    yield return StartRoomGame();
    Assert.IsTrue(gameManager.IsGameStarting);
}
```

### System Integration Tests

#### Network Resilience Tests
```csharp
public class NetworkResilienceTests {
    [UnityTest]
    public IEnumerator WebSocketReconnectionDuringMatching() {
        // 1. 매칭 시작
        yield return StartRandomMatching(2);
        
        // 2. WebSocket 연결 강제 해제
        networkManager.ForceDisconnectWebSocket();
        Assert.IsFalse(networkManager.IsWebSocketConnected);
        
        // 3. 자동 재연결 확인
        yield return WaitForSeconds(5f);
        Assert.IsTrue(networkManager.IsWebSocketConnected);
        
        // 4. 매칭 상태 복구 확인
        Assert.AreEqual(MatchingState.Searching, matchingManager.CurrentState);
    }
    
    [UnityTest]
    public IEnumerator HTTPFallbackDuringEnergyPurchase() {
        // 1. 네트워크 불안정 시뮬레이션
        networkManager.SimulateNetworkInstability(true);
        
        // 2. 피로도 구매 시도
        var purchaseTask = energyManager.PurchaseEnergy(10);
        yield return new WaitUntil(() => purchaseTask.IsCompleted);
        
        // 3. 재시도 메커니즘 확인
        Assert.IsTrue(purchaseTask.Result, "재시도를 통한 구매 성공");
        
        // 4. 네트워크 복구
        networkManager.SimulateNetworkInstability(false);
    }
}
```

#### Data Consistency Tests
```csharp
public class DataConsistencyTests {
    [UnityTest]
    public IEnumerator ProfileChangeConsistency() {
        // 1. 프로필 변경
        string newProfileId = "profile_002";
        yield return ChangeProfile(newProfileId);
        
        // 2. UI 반영 확인
        Assert.AreEqual(newProfileId, profileSection.GetCurrentProfileId());
        
        // 3. UserDataManager 동기화 확인
        Assert.AreEqual(newProfileId, userDataManager.GetCurrentUser().profileId);
        
        // 4. 서버 동기화 확인
        yield return VerifyServerSync();
        Assert.IsTrue(serverSyncResult.IsSuccess);
        
        // 5. 앱 재시작 후 일관성 확인
        yield return RestartApp();
        Assert.AreEqual(newProfileId, profileSection.GetCurrentProfileId());
    }
    
    [UnityTest]
    public IEnumerator EnergyDataConsistency() {
        // 1. 초기 피로도 설정
        int initialEnergy = 50;
        energyManager.SetEnergy(initialEnergy);
        
        // 2. 게임 플레이로 피로도 소모
        yield return ConsumeEnergyByGameplay(5);
        
        // 3. 로컬 데이터 확인
        Assert.AreEqual(45, energyManager.GetCurrentEnergy());
        
        // 4. 서버 데이터 동기화 확인
        yield return SyncWithServer();
        Assert.AreEqual(45, serverEnergyData.currentEnergy);
        
        // 5. 피로도 자동 회복 테스트
        yield return WaitForEnergyRecovery(60f); // 1분 대기
        Assert.IsTrue(energyManager.GetCurrentEnergy() > 45);
    }
}
```

### Error Recovery Tests

#### Critical Error Scenarios
```csharp
public class CriticalErrorTests {
    [UnityTest]
    public IEnumerator MatchingTimeoutRecovery() {
        // 1. 매칭 시작
        yield return StartRandomMatching(4);
        
        // 2. 서버 응답 없음 시뮬레이션
        networkManager.SimulateServerTimeout(true);
        
        // 3. 타임아웃 발생 확인
        yield return WaitForSeconds(65f); // 60초 타임아웃 + 여유
        Assert.AreEqual(MatchingState.Failed, matchingManager.CurrentState);
        
        // 4. 사용자에게 적절한 메시지 표시 확인
        Assert.IsTrue(errorDialog.IsVisible);
        Assert.IsTrue(errorDialog.GetMessage().Contains("매칭"));
        
        // 5. 재시도 가능 상태 확인
        Assert.IsTrue(matchingUI.IsRetryButtonEnabled);
    }
    
    [UnityTest]
    public IEnumerator EnergyPurchaseFailureRecovery() {
        // 1. 구매 시도
        int initialCurrency = currencyManager.GetCurrency("coins");
        var purchaseTask = energyManager.PurchaseEnergy(25);
        
        // 2. 결제 실패 시뮬레이션
        networkManager.SimulatePaymentFailure();
        yield return new WaitUntil(() => purchaseTask.IsCompleted);
        
        // 3. 롤백 확인
        Assert.IsFalse(purchaseTask.Result);
        Assert.AreEqual(initialCurrency, currencyManager.GetCurrency("coins"));
        Assert.AreEqual(0, energyManager.GetCurrentEnergy()); // 원래 상태 유지
        
        // 4. 에러 메시지 표시 확인
        Assert.IsTrue(errorDialog.IsVisible);
        Assert.IsTrue(errorDialog.GetMessage().Contains("구매"));
    }
}
```

### Performance & Memory Tests
```csharp
public class PerformanceTests {
    [UnityTest]
    public IEnumerator MemoryLeakDetection() {
        // 1. 초기 메모리 측정
        long initialMemory = GC.GetTotalMemory(true);
        
        // 2. 반복적인 매칭 및 취소 (메모리 누수 유발 시도)
        for (int i = 0; i < 50; i++) {
            yield return StartRandomMatching(2);
            yield return CancelMatching();
            yield return WaitForFrame();
        }
        
        // 3. 가비지 컬렉션 강제 실행
        GC.Collect();
        GC.WaitForPendingFinalizers();
        GC.Collect();
        
        // 4. 메모리 사용량 검증
        long finalMemory = GC.GetTotalMemory(false);
        long memoryIncrease = finalMemory - initialMemory;
        
        Assert.IsTrue(memoryIncrease < 10 * 1024 * 1024, // 10MB 이하
            $"메모리 누수 의심: {memoryIncrease / 1024 / 1024}MB 증가");
    }
    
    [UnityTest]
    public IEnumerator UIPerformanceTest() {
        // 1. FPS 모니터링 시작
        var fpsCounter = new FPSCounter();
        fpsCounter.StartMonitoring();
        
        // 2. UI 집약적 작업 수행
        yield return PerformUIStressTest();
        
        // 3. FPS 확인
        float averageFPS = fpsCounter.GetAverageFPS();
        Assert.IsTrue(averageFPS >= 55f, $"FPS 기준 미달: {averageFPS:F1}");
        
        fpsCounter.StopMonitoring();
    }
}
```

## Error Handling Improvements

### Global Error Handler Enhancement
```csharp
public class MainPageErrorHandler : MonoBehaviour {
    public void HandleCriticalError(Exception exception, string context) {
        // 1. 에러 로깅
        Debug.LogError($"Critical error in {context}: {exception}");
        
        // 2. 사용자 친화적 메시지 표시
        ShowUserFriendlyErrorMessage(context, exception);
        
        // 3. 상태 복구 시도
        AttemptStateRecovery(context);
        
        // 4. 필요시 안전 모드 활성화
        if (IsCriticalSystemError(exception)) {
            ActivateSafeMode();
        }
    }
    
    void AttemptStateRecovery(string context) {
        switch (context) {
            case "Matching":
                matchingManager.ResetToIdleState();
                break;
            case "Energy":
                energyManager.RefreshFromServer();
                break;
            case "Profile":
                profileManager.ReloadFromUserData();
                break;
        }
    }
}
```

## Acceptance Criteria

### Integration Test Coverage
- [ ] 모든 주요 사용자 플로우 시나리오 테스트 통과
- [ ] 시스템 간 데이터 일관성 100% 검증
- [ ] 네트워크 장애 상황 복구 테스트 통과
- [ ] 메모리 누수 없음 (50회 반복 테스트)
- [ ] 성능 기준 달성 (FPS 55 이상, 로딩 3초 이내)

### Error Handling Robustness
- [ ] 모든 에러 시나리오에서 안전한 복구
- [ ] 사용자 친화적 에러 메시지 표시
- [ ] 데이터 손실 방지 메커니즘 동작
- [ ] 크리티컬 에러 시 안전 모드 활성화

### System Stability
- [ ] 24시간 연속 실행 안정성 테스트 통과
- [ ] 동시 다중 작업 처리 안정성 확인
- [ ] 리소스 사용량 최적화 (메모리, CPU, 네트워크)

## Testing Infrastructure

### Test Utilities
```csharp
public class TestUtilities {
    public static IEnumerator WaitForCondition(Func<bool> condition, float timeout = 10f) {
        float timer = 0f;
        while (timer < timeout && !condition()) {
            yield return null;
            timer += Time.deltaTime;
        }
        Assert.IsTrue(condition(), $"Condition not met within {timeout}s");
    }
    
    public static void SimulateUserInput(Button button) {
        button.onClick.Invoke();
    }
    
    public static IEnumerator SimulateNetworkDelay(float seconds) {
        yield return new WaitForSeconds(seconds);
    }
}
```

### Mock Services
```csharp
public class MockWebSocketServer {
    public void SimulateMatchingResponse(float delay, bool success) {
        StartCoroutine(DelayedResponse(delay, success));
    }
    
    IEnumerator DelayedResponse(float delay, bool success) {
        yield return new WaitForSeconds(delay);
        
        var response = new MatchingResponse {
            success = success,
            roomId = success ? "test_room_001" : null,
            error = success ? null : "Matching failed"
        };
        
        networkManager.TriggerWebSocketMessage(JsonUtility.ToJson(response));
    }
}
```

## Definition of Done
- [ ] 전체 50개 이상의 통합 테스트 시나리오 모두 통과
- [ ] 메모리 누수 및 성능 문제 완전 해결
- [ ] 모든 에러 시나리오에서 안전한 복구 확인
- [ ] 네트워크 불안정 환경에서 시스템 안정성 검증
- [ ] 24시간 안정성 테스트 통과
- [ ] 코드 커버리지 90% 이상 달성
- [ ] 모든 컴포넌트 간 데이터 일관성 보장
- [ ] 사용자 경험 품질 최종 검증 완료